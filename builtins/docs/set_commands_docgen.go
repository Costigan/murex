package docs

func init() {

	Definition["set"] = "# _murex_ Language Guide\n\n## Command Reference: `set`\n\n> Define a local variable and set it's value\n\n### Description\n\nDefines, updates or deallocates a local variable.\n\n### Usage\n\n    <stdin> -> set var_name\n    \n    # Assume value from STDIN, define the data type manually\n    <stdin> -> set datatype var_name\n    \n    # Define value manually (data type defaults to string; `str`)\n    set var_name=data\n    \n    # Define value and data type manually\n    set datatype var_name=data\n    \n    # Define a variable but don't set any value\n    set var_name\n    set datatype var_name\n\n### Examples\n\nAs a method:\n\n    » out \"Hello, world!\" -> set hw\n    » out \"$hw\"\n    Hello, World!\n    \nAs a function:\n\n    » set hw=\"Hello, world!\"\n    » out \"$hw\"\n    Hello, World!\n\n### Detail\n\n#### Deallocation\n\nYou can unset variable names with the bang prefix:\n\n    !set var_name\n    \n#### Scoping\n\nVariables are only scoped inside the code block they're defined in (or any\nchildren of that code block). For example `$foo` will return an empty string in\nthe following code because it's defined within a `try` block then being queried\noutside of the `try` block:\n\n    » try {\n    »     set foo=bar\n    » }\n    » out \"foo: $foo\"\n    foo:\n    \nHowever if we define `$foo` above the `try` block then it's value will be changed\neven though it is being set inside the `try` block:\n\n    » set foo\n    » try {\n    »     set foo=bar\n    » }\n    » out \"foo: $foo\"\n    foo: bar\n    \nSo unlike the previous example, this will return `bar`.\n\nIt's also worth remembering that any variable defined in the shell's FID (ie\nnaked in the interactive shell or otherwise outside of a function or method) is\nliterally the same as using `global`\n\n#### Function Names\n\nAs a security feature function names cannot include variables. This is done to\nreduce the risk of code executing by mistake due to executables being hidden\nbehind variable names.\n\nInstead _murex_ will assume you want the output of the variable printed:\n\n    » out \"Hello, world!\" -> set hw\n    » $hw\n    Hello, world!\n    \nOn the rare occasions you want to force variables to be expanded inside a\nfunction name, then call that function via `exec`:\n\n    » set cmd=grep\n    » ls -> exec: $cmd main.go\n    main.go\n    \n#### Usage Inside Quotation Marks\n\nLike with Bash, Perl and PHP: _murex_ will expand the variable when it is used\ninside a double quotes but will escape the variable name when used inside single\nquotes:\n\n    » out \"$foo\"\n    bar\n    \n    » out '$foo'\n    $foo\n    \n    » out ($foo)\n    bar\n    \n#### Declaration Without Values\n\nYou can declare a variable without a value. This is largely only of use when\nyou want to overide the scoping of a variable inside a nested code-block.\n(see the text above about variable scoping).\n\n### Synonyms\n\n* `set`\n* `!set`\n\n\n### See Also\n\n* [`(` (brace quote)](../commands/brace-quote.md):\n  Write a string to the STDOUT without new line\n* [`exec`](../commands/exec.md):\n  Runs an executable\n* [`export`](../commands/export.md):\n  Define a local variable and set it's value\n* [`global`](../commands/global.md):\n  Define a global variable and set it's value\n* [equ](../commands/equ.md):\n  \n* [let](../commands/let.md):\n  \n* [square-bracket-open](../commands/square-bracket-open.md):\n  "

}
